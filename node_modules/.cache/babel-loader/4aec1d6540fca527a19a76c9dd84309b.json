{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tapable_1 = require(\"tapable\");\n\nconst compilerHookMap = new WeakMap();\nexports.legacyHookMap = {\n  serviceBeforeStart: 'fork-ts-checker-service-before-start',\n  cancel: 'fork-ts-checker-cancel',\n  serviceStartError: 'fork-ts-checker-service-start-error',\n  waiting: 'fork-ts-checker-waiting',\n  serviceStart: 'fork-ts-checker-service-start',\n  receive: 'fork-ts-checker-receive',\n  serviceOutOfMemory: 'fork-ts-checker-service-out-of-memory',\n  emit: 'fork-ts-checker-emit',\n  done: 'fork-ts-checker-done'\n};\n\nfunction createForkTsCheckerWebpackPluginHooks() {\n  return {\n    serviceBeforeStart: new tapable_1.AsyncSeriesHook([]),\n    cancel: new tapable_1.SyncHook(['cancellationToken']),\n    serviceStartError: new tapable_1.SyncHook(['error']),\n    waiting: new tapable_1.SyncHook(['hasTsLint']),\n    serviceStart: new tapable_1.SyncHook(['tsconfigPath', 'tslintPath', 'watchPaths', 'workersNumber', 'memoryLimit']),\n    receive: new tapable_1.SyncHook(['diagnostics', 'lints']),\n    serviceOutOfMemory: new tapable_1.SyncHook([]),\n    emit: new tapable_1.SyncHook(['diagnostics', 'lints', 'elapsed']),\n    done: new tapable_1.SyncHook(['diagnostics', 'lints', 'elapsed'])\n  };\n}\n\nfunction getForkTsCheckerWebpackPluginHooks(compiler) {\n  let hooks = compilerHookMap.get(compiler);\n\n  if (hooks === undefined) {\n    hooks = createForkTsCheckerWebpackPluginHooks();\n    compilerHookMap.set(compiler, hooks);\n  }\n\n  return hooks;\n}\n\nexports.getForkTsCheckerWebpackPluginHooks = getForkTsCheckerWebpackPluginHooks;","map":null,"metadata":{},"sourceType":"script"}