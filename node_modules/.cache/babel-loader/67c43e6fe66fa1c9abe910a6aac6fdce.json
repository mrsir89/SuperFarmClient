{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass HookCodeFactory {\n  constructor(config) {\n    this.config = config;\n    this.options = undefined;\n    this._args = undefined;\n  }\n\n  create(options) {\n    this.init(options);\n    let fn;\n\n    switch (this.options.type) {\n      case \"sync\":\n        fn = new Function(this.args(), '\"use strict\";\\n' + this.header() + this.content({\n          onError: err => \"throw \".concat(err, \";\\n\"),\n          onResult: result => \"return \".concat(result, \";\\n\"),\n          resultReturns: true,\n          onDone: () => \"\",\n          rethrowIfPossible: true\n        }));\n        break;\n\n      case \"async\":\n        fn = new Function(this.args({\n          after: \"_callback\"\n        }), '\"use strict\";\\n' + this.header() + this.content({\n          onError: err => \"_callback(\".concat(err, \");\\n\"),\n          onResult: result => \"_callback(null, \".concat(result, \");\\n\"),\n          onDone: () => \"_callback();\\n\"\n        }));\n        break;\n\n      case \"promise\":\n        let errorHelperUsed = false;\n        const content = this.content({\n          onError: err => {\n            errorHelperUsed = true;\n            return \"_error(\".concat(err, \");\\n\");\n          },\n          onResult: result => \"_resolve(\".concat(result, \");\\n\"),\n          onDone: () => \"_resolve();\\n\"\n        });\n        let code = \"\";\n        code += '\"use strict\";\\n';\n        code += \"return new Promise((_resolve, _reject) => {\\n\";\n\n        if (errorHelperUsed) {\n          code += \"var _sync = true;\\n\";\n          code += \"function _error(_err) {\\n\";\n          code += \"if(_sync)\\n\";\n          code += \"_resolve(Promise.resolve().then(() => { throw _err; }));\\n\";\n          code += \"else\\n\";\n          code += \"_reject(_err);\\n\";\n          code += \"};\\n\";\n        }\n\n        code += this.header();\n        code += content;\n\n        if (errorHelperUsed) {\n          code += \"_sync = false;\\n\";\n        }\n\n        code += \"});\\n\";\n        fn = new Function(this.args(), code);\n        break;\n    }\n\n    this.deinit();\n    return fn;\n  }\n\n  setup(instance, options) {\n    instance._x = options.taps.map(t => t.fn);\n  }\n  /**\n   * @param {{ type: \"sync\" | \"promise\" | \"async\", taps: Array<Tap>, interceptors: Array<Interceptor> }} options\n   */\n\n\n  init(options) {\n    this.options = options;\n    this._args = options.args.slice();\n  }\n\n  deinit() {\n    this.options = undefined;\n    this._args = undefined;\n  }\n\n  header() {\n    let code = \"\";\n\n    if (this.needContext()) {\n      code += \"var _context = {};\\n\";\n    } else {\n      code += \"var _context;\\n\";\n    }\n\n    code += \"var _x = this._x;\\n\";\n\n    if (this.options.interceptors.length > 0) {\n      code += \"var _taps = this.taps;\\n\";\n      code += \"var _interceptors = this.interceptors;\\n\";\n    }\n\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n\n      if (interceptor.call) {\n        code += \"\".concat(this.getInterceptor(i), \".call(\").concat(this.args({\n          before: interceptor.context ? \"_context\" : undefined\n        }), \");\\n\");\n      }\n    }\n\n    return code;\n  }\n\n  needContext() {\n    for (const tap of this.options.taps) if (tap.context) return true;\n\n    return false;\n  }\n\n  callTap(tapIndex, {\n    onError,\n    onResult,\n    onDone,\n    rethrowIfPossible\n  }) {\n    let code = \"\";\n    let hasTapCached = false;\n\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n\n      if (interceptor.tap) {\n        if (!hasTapCached) {\n          code += \"var _tap\".concat(tapIndex, \" = \").concat(this.getTap(tapIndex), \";\\n\");\n          hasTapCached = true;\n        }\n\n        code += \"\".concat(this.getInterceptor(i), \".tap(\").concat(interceptor.context ? \"_context, \" : \"\", \"_tap\").concat(tapIndex, \");\\n\");\n      }\n    }\n\n    code += \"var _fn\".concat(tapIndex, \" = \").concat(this.getTapFn(tapIndex), \";\\n\");\n    const tap = this.options.taps[tapIndex];\n\n    switch (tap.type) {\n      case \"sync\":\n        if (!rethrowIfPossible) {\n          code += \"var _hasError\".concat(tapIndex, \" = false;\\n\");\n          code += \"try {\\n\";\n        }\n\n        if (onResult) {\n          code += \"var _result\".concat(tapIndex, \" = _fn\").concat(tapIndex, \"(\").concat(this.args({\n            before: tap.context ? \"_context\" : undefined\n          }), \");\\n\");\n        } else {\n          code += \"_fn\".concat(tapIndex, \"(\").concat(this.args({\n            before: tap.context ? \"_context\" : undefined\n          }), \");\\n\");\n        }\n\n        if (!rethrowIfPossible) {\n          code += \"} catch(_err) {\\n\";\n          code += \"_hasError\".concat(tapIndex, \" = true;\\n\");\n          code += onError(\"_err\");\n          code += \"}\\n\";\n          code += \"if(!_hasError\".concat(tapIndex, \") {\\n\");\n        }\n\n        if (onResult) {\n          code += onResult(\"_result\".concat(tapIndex));\n        }\n\n        if (onDone) {\n          code += onDone();\n        }\n\n        if (!rethrowIfPossible) {\n          code += \"}\\n\";\n        }\n\n        break;\n\n      case \"async\":\n        let cbCode = \"\";\n        if (onResult) cbCode += \"(_err\".concat(tapIndex, \", _result\").concat(tapIndex, \") => {\\n\");else cbCode += \"_err\".concat(tapIndex, \" => {\\n\");\n        cbCode += \"if(_err\".concat(tapIndex, \") {\\n\");\n        cbCode += onError(\"_err\".concat(tapIndex));\n        cbCode += \"} else {\\n\";\n\n        if (onResult) {\n          cbCode += onResult(\"_result\".concat(tapIndex));\n        }\n\n        if (onDone) {\n          cbCode += onDone();\n        }\n\n        cbCode += \"}\\n\";\n        cbCode += \"}\";\n        code += \"_fn\".concat(tapIndex, \"(\").concat(this.args({\n          before: tap.context ? \"_context\" : undefined,\n          after: cbCode\n        }), \");\\n\");\n        break;\n\n      case \"promise\":\n        code += \"var _hasResult\".concat(tapIndex, \" = false;\\n\");\n        code += \"var _promise\".concat(tapIndex, \" = _fn\").concat(tapIndex, \"(\").concat(this.args({\n          before: tap.context ? \"_context\" : undefined\n        }), \");\\n\");\n        code += \"if (!_promise\".concat(tapIndex, \" || !_promise\").concat(tapIndex, \".then)\\n\");\n        code += \"  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise\".concat(tapIndex, \" + ')');\\n\");\n        code += \"_promise\".concat(tapIndex, \".then(_result\").concat(tapIndex, \" => {\\n\");\n        code += \"_hasResult\".concat(tapIndex, \" = true;\\n\");\n\n        if (onResult) {\n          code += onResult(\"_result\".concat(tapIndex));\n        }\n\n        if (onDone) {\n          code += onDone();\n        }\n\n        code += \"}, _err\".concat(tapIndex, \" => {\\n\");\n        code += \"if(_hasResult\".concat(tapIndex, \") throw _err\").concat(tapIndex, \";\\n\");\n        code += onError(\"_err\".concat(tapIndex));\n        code += \"});\\n\";\n        break;\n    }\n\n    return code;\n  }\n\n  callTapsSeries({\n    onError,\n    onResult,\n    resultReturns,\n    onDone,\n    doneReturns,\n    rethrowIfPossible\n  }) {\n    if (this.options.taps.length === 0) return onDone();\n    const firstAsync = this.options.taps.findIndex(t => t.type !== \"sync\");\n    const somethingReturns = resultReturns || doneReturns || false;\n    let code = \"\";\n    let current = onDone;\n\n    for (let j = this.options.taps.length - 1; j >= 0; j--) {\n      const i = j;\n      const unroll = current !== onDone && this.options.taps[i].type !== \"sync\";\n\n      if (unroll) {\n        code += \"function _next\".concat(i, \"() {\\n\");\n        code += current();\n        code += \"}\\n\";\n\n        current = () => \"\".concat(somethingReturns ? \"return \" : \"\", \"_next\").concat(i, \"();\\n\");\n      }\n\n      const done = current;\n\n      const doneBreak = skipDone => {\n        if (skipDone) return \"\";\n        return onDone();\n      };\n\n      const content = this.callTap(i, {\n        onError: error => onError(i, error, done, doneBreak),\n        onResult: onResult && (result => {\n          return onResult(i, result, done, doneBreak);\n        }),\n        onDone: !onResult && done,\n        rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)\n      });\n\n      current = () => content;\n    }\n\n    code += current();\n    return code;\n  }\n\n  callTapsLooping({\n    onError,\n    onDone,\n    rethrowIfPossible\n  }) {\n    if (this.options.taps.length === 0) return onDone();\n    const syncOnly = this.options.taps.every(t => t.type === \"sync\");\n    let code = \"\";\n\n    if (!syncOnly) {\n      code += \"var _looper = () => {\\n\";\n      code += \"var _loopAsync = false;\\n\";\n    }\n\n    code += \"var _loop;\\n\";\n    code += \"do {\\n\";\n    code += \"_loop = false;\\n\";\n\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n\n      if (interceptor.loop) {\n        code += \"\".concat(this.getInterceptor(i), \".loop(\").concat(this.args({\n          before: interceptor.context ? \"_context\" : undefined\n        }), \");\\n\");\n      }\n    }\n\n    code += this.callTapsSeries({\n      onError,\n      onResult: (i, result, next, doneBreak) => {\n        let code = \"\";\n        code += \"if(\".concat(result, \" !== undefined) {\\n\");\n        code += \"_loop = true;\\n\";\n        if (!syncOnly) code += \"if(_loopAsync) _looper();\\n\";\n        code += doneBreak(true);\n        code += \"} else {\\n\";\n        code += next();\n        code += \"}\\n\";\n        return code;\n      },\n      onDone: onDone && (() => {\n        let code = \"\";\n        code += \"if(!_loop) {\\n\";\n        code += onDone();\n        code += \"}\\n\";\n        return code;\n      }),\n      rethrowIfPossible: rethrowIfPossible && syncOnly\n    });\n    code += \"} while(_loop);\\n\";\n\n    if (!syncOnly) {\n      code += \"_loopAsync = true;\\n\";\n      code += \"};\\n\";\n      code += \"_looper();\\n\";\n    }\n\n    return code;\n  }\n\n  callTapsParallel({\n    onError,\n    onResult,\n    onDone,\n    rethrowIfPossible,\n    onTap = (i, run) => run()\n  }) {\n    if (this.options.taps.length <= 1) {\n      return this.callTapsSeries({\n        onError,\n        onResult,\n        onDone,\n        rethrowIfPossible\n      });\n    }\n\n    let code = \"\";\n    code += \"do {\\n\";\n    code += \"var _counter = \".concat(this.options.taps.length, \";\\n\");\n\n    if (onDone) {\n      code += \"var _done = () => {\\n\";\n      code += onDone();\n      code += \"};\\n\";\n    }\n\n    for (let i = 0; i < this.options.taps.length; i++) {\n      const done = () => {\n        if (onDone) return \"if(--_counter === 0) _done();\\n\";else return \"--_counter;\";\n      };\n\n      const doneBreak = skipDone => {\n        if (skipDone || !onDone) return \"_counter = 0;\\n\";else return \"_counter = 0;\\n_done();\\n\";\n      };\n\n      code += \"if(_counter <= 0) break;\\n\";\n      code += onTap(i, () => this.callTap(i, {\n        onError: error => {\n          let code = \"\";\n          code += \"if(_counter > 0) {\\n\";\n          code += onError(i, error, done, doneBreak);\n          code += \"}\\n\";\n          return code;\n        },\n        onResult: onResult && (result => {\n          let code = \"\";\n          code += \"if(_counter > 0) {\\n\";\n          code += onResult(i, result, done, doneBreak);\n          code += \"}\\n\";\n          return code;\n        }),\n        onDone: !onResult && (() => {\n          return done();\n        }),\n        rethrowIfPossible\n      }), done, doneBreak);\n    }\n\n    code += \"} while(false);\\n\";\n    return code;\n  }\n\n  args({\n    before,\n    after\n  } = {}) {\n    let allArgs = this._args;\n    if (before) allArgs = [before].concat(allArgs);\n    if (after) allArgs = allArgs.concat(after);\n\n    if (allArgs.length === 0) {\n      return \"\";\n    } else {\n      return allArgs.join(\", \");\n    }\n  }\n\n  getTapFn(idx) {\n    return \"_x[\".concat(idx, \"]\");\n  }\n\n  getTap(idx) {\n    return \"_taps[\".concat(idx, \"]\");\n  }\n\n  getInterceptor(idx) {\n    return \"_interceptors[\".concat(idx, \"]\");\n  }\n\n}\n\nmodule.exports = HookCodeFactory;","map":null,"metadata":{},"sourceType":"script"}