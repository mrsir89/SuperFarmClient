{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass Hook {\n  constructor(args) {\n    if (!Array.isArray(args)) args = [];\n    this._args = args;\n    this.taps = [];\n    this.interceptors = [];\n    this.call = this._call;\n    this.promise = this._promise;\n    this.callAsync = this._callAsync;\n    this._x = undefined;\n  }\n\n  compile(options) {\n    throw new Error(\"Abstract: should be overriden\");\n  }\n\n  _createCall(type) {\n    return this.compile({\n      taps: this.taps,\n      interceptors: this.interceptors,\n      args: this._args,\n      type: type\n    });\n  }\n\n  tap(options, fn) {\n    if (typeof options === \"string\") options = {\n      name: options\n    };\n    if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tap(options: Object, fn: function)\");\n    options = Object.assign({\n      type: \"sync\",\n      fn: fn\n    }, options);\n    if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tap\");\n    options = this._runRegisterInterceptors(options);\n\n    this._insert(options);\n  }\n\n  tapAsync(options, fn) {\n    if (typeof options === \"string\") options = {\n      name: options\n    };\n    if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tapAsync(options: Object, fn: function)\");\n    options = Object.assign({\n      type: \"async\",\n      fn: fn\n    }, options);\n    if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tapAsync\");\n    options = this._runRegisterInterceptors(options);\n\n    this._insert(options);\n  }\n\n  tapPromise(options, fn) {\n    if (typeof options === \"string\") options = {\n      name: options\n    };\n    if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tapPromise(options: Object, fn: function)\");\n    options = Object.assign({\n      type: \"promise\",\n      fn: fn\n    }, options);\n    if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tapPromise\");\n    options = this._runRegisterInterceptors(options);\n\n    this._insert(options);\n  }\n\n  _runRegisterInterceptors(options) {\n    for (const interceptor of this.interceptors) {\n      if (interceptor.register) {\n        const newOptions = interceptor.register(options);\n        if (newOptions !== undefined) options = newOptions;\n      }\n    }\n\n    return options;\n  }\n\n  withOptions(options) {\n    const mergeOptions = opt => Object.assign({}, options, typeof opt === \"string\" ? {\n      name: opt\n    } : opt); // Prevent creating endless prototype chains\n\n\n    options = Object.assign({}, options, this._withOptions);\n    const base = this._withOptionsBase || this;\n    const newHook = Object.create(base);\n    newHook.tapAsync = (opt, fn) => base.tapAsync(mergeOptions(opt), fn), newHook.tap = (opt, fn) => base.tap(mergeOptions(opt), fn);\n\n    newHook.tapPromise = (opt, fn) => base.tapPromise(mergeOptions(opt), fn);\n\n    newHook._withOptions = options;\n    newHook._withOptionsBase = base;\n    return newHook;\n  }\n\n  isUsed() {\n    return this.taps.length > 0 || this.interceptors.length > 0;\n  }\n\n  intercept(interceptor) {\n    this._resetCompilation();\n\n    this.interceptors.push(Object.assign({}, interceptor));\n\n    if (interceptor.register) {\n      for (let i = 0; i < this.taps.length; i++) this.taps[i] = interceptor.register(this.taps[i]);\n    }\n  }\n\n  _resetCompilation() {\n    this.call = this._call;\n    this.callAsync = this._callAsync;\n    this.promise = this._promise;\n  }\n\n  _insert(item) {\n    this._resetCompilation();\n\n    let before;\n    if (typeof item.before === \"string\") before = new Set([item.before]);else if (Array.isArray(item.before)) {\n      before = new Set(item.before);\n    }\n    let stage = 0;\n    if (typeof item.stage === \"number\") stage = item.stage;\n    let i = this.taps.length;\n\n    while (i > 0) {\n      i--;\n      const x = this.taps[i];\n      this.taps[i + 1] = x;\n      const xStage = x.stage || 0;\n\n      if (before) {\n        if (before.has(x.name)) {\n          before.delete(x.name);\n          continue;\n        }\n\n        if (before.size > 0) {\n          continue;\n        }\n      }\n\n      if (xStage > stage) {\n        continue;\n      }\n\n      i++;\n      break;\n    }\n\n    this.taps[i] = item;\n  }\n\n}\n\nfunction createCompileDelegate(name, type) {\n  return function lazyCompileHook(...args) {\n    this[name] = this._createCall(type);\n    return this[name](...args);\n  };\n}\n\nObject.defineProperties(Hook.prototype, {\n  _call: {\n    value: createCompileDelegate(\"call\", \"sync\"),\n    configurable: true,\n    writable: true\n  },\n  _promise: {\n    value: createCompileDelegate(\"promise\", \"promise\"),\n    configurable: true,\n    writable: true\n  },\n  _callAsync: {\n    value: createCompileDelegate(\"callAsync\", \"async\"),\n    configurable: true,\n    writable: true\n  }\n});\nmodule.exports = Hook;","map":null,"metadata":{},"sourceType":"script"}